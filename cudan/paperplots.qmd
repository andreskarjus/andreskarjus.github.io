---
title: "Quantifying the global film festival circuit: networks, diversity and value creation"
knitr:
  opts_chunk: 
    echo: false
    message: false
    warning: false
format: 
  html:
    background-color: white
    fig-width: 9
    fig-height: 6
    out-width: "100%"
    embed-resources: true
    toc: true
    toc-location: left
    toc-depth: 6
    include-in-header: myheader.html
    search: false
    grid:
      sidebar-width: 200px
      body-width: 1300px
      margin-width: 0px
editor: source
---



**Abstract** Film festivals are a key component in the global film industry in terms of trendsetting, publicity, trade and collaboration. We present an unprecedented quantitative analysis of the international film festival circuit, which has so far remained relatively understudied, partly due to the limited availability of suitable databases. Here we use large-scale data from the Cinando platform of Marché du Film, widely used by industry professionals. We explicitly model festival events as a global network connected by shared films, and quantify festivals as the sum of the metadata of their constituent parts, in this case, the showcased films. Importantly, we argue against using simple count distributions for discrete labels such as genre or production country, as such categories are typically not equidistant. Rather, we propose embedding them in continuous latent vector spaces. We demonstrate how these “festival embeddings” provide insight into changes in programmed content over time, predict festival connections, and can be used to measure diversity in film festival programming across various cultural and geographical variables - and by proxy, estimate public value creation. Our results provide a novel mapping of the film festival circuit between 2009-2021 (618 festivals, 32700 unique films), highlighting festival types that occupy specific niches, diverse series, and those that evolve over time. With festivals occupying a central position in the film industry, investigations into the data they generate hold opportunities for researchers to better understand industry dynamics and cultural impact, and for organizers, as well as industry and market actors, to make more informed, data-driven decisions. We hope that our proposed methodological approach to festival data, content and diversity paves way for a more comprehensive film festival science, as well as quantitative event science more broadly.


```{r}
library(plotly)
library(tidyverse)
library(colorspace)
library(ggbeeswarm)
library(ggrepel)
library(patchwork)
library(visNetwork)
library(rworldmap)
library(scales)
library(igraph)
library(ggraph)
library(tidygraph)
library(PieGlyph)
# library(lemon)

load("C:/Users/Andres/korpused/publicvalue/cinando/cinandospaces.RData")
load("C:/Users/Andres/korpused/publicvalue/cinando/cinandonetworks.RData")

convertplots=T


abcols= divergingx_hcl(6, palette="Zissou 1")[c(1,4)] %>% c("gray2") %>% desaturate(0.6) #%>% show_col
abshapes=c(16,4)

sixgcols = c(divergingx_hcl(6, palette="Zissou 1") %>% {.[6]=darken(.[6],0.3);.},  "gray80") %>%
  {.[1]=lighten(.[1],0.2);.} %>% {.[3] = "#03408f";.} %>% 
  {.[c(2)]=darken(.[c(2)],0.1);.} %>% 
  {.[c(1,4,2,5,3,6,7)]} # %>%  show_col
sixcols = c(divergingx_hcl(6, palette="Zissou 1"), "gray10",  "gray80") %>% {.[c(1)]=lighten(.[c(1)],0.5);.} %>% {.[c(2)]=darken(.[c(1)],0.5);.} %>% {.[c(4)]=lighten(.[c(4)],0.2);.} %>% {.[7]=darken(.[1],0.75);.} # %>% show_col
langcols= c(divergingx_hcl(6, palette="Zissou 1") %>% 
              {.[c(1)]=darken(.[c(1)],0);.} %>% 
              {.[7]=darken(.[1],0.6);.} ,  "gray80")[c(1,3,5,6,7,8)] #%>% show_col
rolecols=divergingx_hcl(31, palette="Zissou 1")  %>% {c(.[1:2], "gray75", .[30:31])}
matcols = (divergingx_hcl(8, palette="Zissou 1")[c(3,5,7)] %>% {.[1]=lighten(.[1],0.4);.} %>%  {.[3]=darken(.[3],0.95);.}) # %>% show_col
netcols =(divergingx_hcl(5, palette="Zissou 1")[c(1,1,2,3)] %>% {.[1]=darken(.[1],0.5);.} %>%  {.[4]=lighten(.[4],0.45);.} ) %>% {c("#01033a", .)} #  %>% show_col


exgenfests = c("Festival de Cannes", "Sundance", "Hot Docs Festival", "Sitges FF")
exgeofests = c("Festival de Cannes", "Sundance", "Tokyo IFF", "Zurich FF")
exlangfests=c("Festival de Cannes", "Sundance", "Busan IFF", "BAFICI")
exrolefests = c("Festival de Cannes", "Sundance","SXSW",  "Berlinale - Berlin IFF")


# allfests = nodelist %>% group_by(libelleFestival_NEW_VZ) %>% filter(n()>3) %>% pull(libelleFestival_NEW_VZ) %>% unique



### functions ####




dopies = function(vecs, tops=NULL){
  mains=levels(vecs$colorgenre) 
  if( !attr(vecs, "tops") %>% is.null){
    tops = attr(vecs, "tops") 
  }
  pies = tops %>% 
   left_join(vecs %>% filter(!duplicated(EventID_VZ)), by="EventID_VZ") %>% 
   select(txtKind, s, EventID_VZ, libelleFestival_NEW_VZ, YearEvent, LibelleEvent_NEW_VZ)   %>% 
  mutate(txtKind=case_when(txtKind%in%mains~txtKind, T~"other")) %>% 
  group_by(EventID_VZ, txtKind) %>% 
  summarise(s=sum(s), 
            across(c(LibelleEvent_NEW_VZ, libelleFestival_NEW_VZ, YearEvent), first), )    %>% 
  ungroup() %>% 
  mutate(colorgenre2=fct_relevel(txtKind, mains)) %>% select(-txtKind) %>% 
  arrange(colorgenre2)
 
  pies2 = pivot_wider(pies , names_from = colorgenre2, values_from=s, values_fill=0 ) %>%
  mutate(event=LibelleEvent_NEW_VZ) %>% 
  group_by(libelleFestival_NEW_VZ) %>% 
  arrange(YearEvent, .by_group = T) %>% 
  ungroup
  attr(pies2, "mains")=mains
return(pies2)
}





div2plot = function(vecs, ex=NULL, convert=T,  colorlab="Main", xlab="Contributing diversity", ylab="Internal diversity", genrecols=sixcols, pies){
  # if(isgenre){
  #     vecs = vecs %>% arrange(YearEvent) %>% 
  #   mutate(colorgenre = 
  #          case_when(firstkind %in% head(names(sort(table(.$firstkind),decreasing = T)),6)~firstkind, T~"other" ) %>% as.factor()) %>% 
  #   mutate(colorgenre = fct_relevel(colorgenre, 
  #                                 c(names(sort(table(colorgenre),decreasing = T)) %>% .[.!="other"], "other") ))
  #     colorlab="Main\ngenre"
  # } else {
  #   vecs = vecs %>% arrange(YearEvent) %>% 
  #   mutate(colorgenre = 
  #          case_when(firstcountry %in% head(names(sort(table(.$firstcountry),decreasing = T)),6)~firstcountry, T~"other" ) %>% as.factor()) %>% 
  #   mutate(colorgenre = fct_relevel(colorgenre, 
  #                                 c(names(sort(table(colorgenre),decreasing = T)) %>% .[.!="other"], "other") ))
    
   # colorlab="Main\nprod.\ncountry"
  #}

  
  g={ggplot(vecs , 
        aes(exdiv, indiv, shape=ab, color=colorgenre, size=ab, text=tool))+
      geom_vline(xintercept = median(vecs$exdiv, na.rm=T) # mean(c(min(vecs$exdiv,na.rm=T), max(vecs$exdiv,na.rm=T)))
                 , color="gray25")+
      geom_hline(yintercept = median(vecs$indiv, na.rm=T)
                #   mean(c(min(vecs$indiv,na.rm=T), max(vecs$indiv,na.rm=T)))
                 , color="gray25")+
      geom_point(#data=vecs %>% filter(!(libelleFestival_NEW_VZ%in%ex)), 
                 alpha=0.7) +
      #geom_point(data=vecs %>% filter((libelleFestival_NEW_VZ%in%ex)), alpha=1)+
    #geom_line(aes(YearEvent, indiv), data=festvecs %>% group_by(YearEvent) %>% summarise(indiv=mean(indiv,na.rm=T)), inherit.aes = F)+
    # geom_path(aes(group=libelleFestival_NEW_VZ), 
    #           vecs %>% filter(libelleFestival_NEW_VZ%in%ex) ,
    #           color="black", 
    #           size=0.2)+
    #scale_color_manual(values=abcols)+
    scale_color_manual(values=genrecols, name=colorlab)+
    scale_shape_manual(values=abshapes, name="Festival")+
    scale_size_manual(values=c(2, 1.2), guide = "none")+
    labs(x=xlab, y=ylab)+
    theme_bw()+
    theme(#legend.position = 'left', 
      #panel.border = element_blank(),
      panel.grid.minor.x = element_blank(),
      plot.background = element_rect(color="white", fill="white")
    )} 
  if(convert){
    ggplotly(g,tooltip="text")
  } else {
    g
  }
}

divyearplot = function(vecs, ex, shape=16, yl="", splitab=T, convert=T, networkstats=T, ylims=NULL, genrecols=sixgcols, pies=NULL, nrowmod=6, contrdiv=T){
  if(splitab){
    vecs = vecs %>% mutate(YearEvent=case_when(ab=="A"~YearEvent-0.15,
                                               ab=="B"~YearEvent+0.15 )) %>% 
      arrange(libelleFestival_NEW_VZ) %>% 
      mutate(series = substr(libelleFestival_NEW_VZ, 1,15))
    if(length(unique(vecs$libelleFestival_NEW_VZ)) != 
       length(unique(vecs$series))){ stop("shortening mismatch")}
    vex=vecs
    g=ggplot(vecs , 
        aes(YearEvent, target, color=ab, shape=ab,  text=tool))
  } else {
     vex = vecs %>% 
       filter(libelleFestival_NEW_VZ %in% ex, !is.na(target)) %>% 
       mutate(libelleFestival_NEW_VZ=fct_relevel(libelleFestival_NEW_VZ, ex))
     g=ggplot(vex , 
        aes(YearEvent, target, color=ab, shape=ab,  text=tool))
  }
 
  
  if(splitab){
    
    col2 = vecs  %>% 
      filter(!duplicated(libelleFestival_NEW_VZ)) %>% 
      mutate(col=case_when(ab=="A"~ abcols[1], T~abcols[2])) %>% 
      pull(col)
    
    if(networkstats){
      fromy=2014.5; toy=2019.5
    } else{
      fromy=2013.5; toy=2021.5
    }
      g= g+
       stat_summary(aes(y = target, group=1), 
                 data=vecs %>% filter(YearEvent>fromy, YearEvent<toy, ab=="A"),
                 fun=mean, na.rm=T,  geom="line", size=2, color=abcols[1])+
        stat_summary(aes(y = target, group=1), 
                 data=vecs %>% filter(YearEvent>fromy, YearEvent<toy, ab=="B",),
                 fun=mean, na.rm=T,  geom="line", size=1.5, color=abcols[2])+
        scale_x_continuous(breaks=2009:2021)
      
      if(convertplots){
        g=g+geom_beeswarm(aes(color=series), # creates legend in ggplotly
                      alpha=1, cex=0.8,size=1.5, priority = "random") +
        scale_color_manual(values=col2)
      } else {
         g=g+geom_beeswarm(aes(color=ab),
                      alpha=1, cex=0.8,size=1.5, priority = "random") +
          scale_color_manual(values=abcols)
      }
        
  } else {
    g=g+scale_color_manual(values=abcols)+
      theme(legend.position = 'none')
  }
  
    g=g+  
    scale_shape_manual(values=abshapes)+
    #scale_size( range=c(0.5*2.2, 1.5*3.2), guide = "none")+
    theme_bw()+
    theme(
      #legend.position = 'none', 
      #panel.border = element_blank(),
      
      panel.grid.major.x  = element_blank(),
       panel.grid.minor.x  = element_line(color="gray80"),
      plot.background = element_rect(color="white", fill="white"),
      axis.title.x = element_blank(),
      axis.ticks.length = unit(0, "inch")
    )+
    labs(y=yl)
  # if(nrow( vecs %>% filter(libelleFestival_NEW_VZ%in%ex))>0){
  #   g=g+geom_line(aes(group=libelleFestival_NEW_VZ), 
  #             vecs %>% filter(libelleFestival_NEW_VZ%in%ex) ,
  #             color="gray40", 
  #             size=0.2)
  # }
  
  if(!splitab & !is.null(ex)){
   if(networkstats){
      fromy=2014.5; toy=2019.5
    } else{
      fromy=2008; toy=2022
      g=g+geom_errorbar(aes(ymin=lower, ymax=upper), color="gray30", width=0.1, size=0.45)
    }
    g=
      g+facet_wrap(~libelleFestival_NEW_VZ, nrow = ceiling(length(ex)/nrowmod))+
      # geom_point( aes(YearEvent, target),data=vecs %>% select(-libelleFestival_NEW_VZ), inherit.aes = F,
      #             color="gray90", size=0.9)+
      geom_line(data=vex %>% filter(YearEvent>fromy, YearEvent<toy) %>% 
                  group_by(YearEvent, libelleFestival_NEW_VZ) %>% 
                  summarise(target=mean(target, na.rm=T), tool=NA, ab=ab[1]), 
                color="gray70", size=0.3
                )+
      geom_point(data=vex, alpha=1, size=1.5, shape=16)+
      theme(
       panel.grid.major.x  = element_line(color="gray95"),
       panel.grid.minor.x  = element_blank(),
       panel.grid.minor.y  = element_blank(),
       legend.position = 'none',
       strip.text = element_text(hjust=0, margin=margin(0.5,0,0.5,1))
       )
    
    if(!is.null(pies)){
      p = dopies(vex, pies)
      m = attr(p, "mains")
      vp = vex %>%  select(EventID_VZ, target,YearEvent,libelleFestival_NEW_VZ) %>% 
        left_join(p %>% select(EventID_VZ, {{m}}),by="EventID_VZ")
      g = g+ geom_pie_glyph(aes(YearEvent, target), data = vp, slices=m, radius=0.2, inherit.aes = F)+
        scale_fill_manual(values=genrecols, breaks=m)
      
    }
    if(contrdiv){
      g = g+geom_errorbar(aes(ymin=elower, ymax=eupper), color="gray60", width=0, size=0.45,
                          position=position_nudge(0.45))+
        geom_point(aes(y=exdiv), color="gray60", size=0.5, shape=15, 
                   position=position_nudge(0.45))+
        theme(axis.title.y.right = element_text(color="gray50"), 
              axis.ticks.length.y.right = unit(0,"in"),
              axis.text.y.right = element_blank())
    }
  }
  
  minx = min(vex$YearEvent, na.rm=T)
  if(!is.null(ylims)){
    g=g+
      coord_cartesian(ylim = ylims, expand=F)+
      scale_x_continuous(breaks=seq(minx+1,2020,3), limits=c(minx-0.4,2021+0.4 ) )
  } else {
    g=g+ scale_x_continuous(breaks=seq(minx+1,2020,3), expand = expansion(0.1,0) )+
      scale_y_continuous(expand=c(0.05,0)
        #limits=c( min(c(vecs$target, vecs$lower), na.rm=T), max(c(vecs$target, vecs$upper), na.rm=T )*1.001 )
        )
        if(contrdiv){
          g=g+scale_y_continuous(expand=c(0.05,0),sec.axis = sec_axis(~., name="Contributing diversity"))
        }
  }
  
  
  if(convert){

    return( ggplotly(g,tooltip="text") %>% plotly::config(doubleClickDelay=500) 
            )
  } else {
    return(g+theme(legend.position = "none"))
           }
  
}


sysplots = function(sysdiv, yl){
  
  g=  ggplot(sysdiv,aes(YearEvent, sysdiv, color=ab))+
    #geom_pointline(position=position_dodge(width = 0.25), distance=unit(10, "pt") )+
    geom_line(data=sysdiv %>% filter(ab=="Both"), position=position_nudge(x = 0.25/3))+
    geom_point(aes(shape=ab, size=ab), position=position_dodge(width = 0.25))+
    geom_errorbar(aes(ymin=slower, ymax=supper),width=0.1, linewidth=0.45,position=position_dodge(width = 0.25) )+
    scale_x_continuous(breaks=2012:2021)+
    scale_color_manual(values=abcols)+
    scale_shape_manual(values=abshapes %>% c(1))+
    scale_size_manual(values=c(0.6, 0.3, 0.7))+
    theme_bw()+
    theme(legend.position = 'none')+
    theme(
      panel.grid.minor.x  = element_blank(),
       panel.grid.minor.y  = element_blank(),
      plot.background = element_rect(color="white", fill="white"),
      axis.title.x = element_blank()
    )+
    labs(y=yl)
 return(g)
}


gg=function(g, do=T){
  if(do){
    ggplotly(g, tooltip="text") %>%  plotly::config(doubleClickDelay=500)
  } else{
    g
  }
}

pspacer=ggplot()+theme_void()+theme(plot.margin = margin(0,0,0,0))

```

```{r, eval=F}


##### treemap for talk ###
# x = read_excel("C:/Users/Andres/korpused/publicvalue/cinando/festivals_june2022/Festival-film list.xlsx") %>% 
# mutate(type=case_when( (is.na(lstTypeEvent) | lstTypeEvent=="Festival") ~ "festival", T~"market")  ) %>% 
#   mutate(tmp=paste0(TitleVA, "_", YearOfProduction )) %>% 
#   mutate(eventtmp = paste0(EventID_VZ, type)) %>% 
#   group_by(eventtmp) %>%   # for duplicate film removal
#   filter(!duplicated(tmp)) %>% 
#   group_by(eventtmp) %>% 
#   mutate(eventtmp2=case_when( (n()>=15 | type=="market") ~ eventtmp, T~"rest")) %>% 
#   group_by(eventtmp2) %>% 
#   mutate(type2 = case_when(type=="market"~"markets", 
#                            eventtmp2=="rest"~"excluded festivals", 
#                            n()>=15~"included festivals",T~"excluded festivals" )) %>% 
#   summarise(nf=n(), ni=n()>=15, LibelleEvent_NEW=LibelleEvent_NEW[1], type2=type2[1]) 
# 
# g=ggplot(x, #%>% mutate(lab=case_when(nf>300~LibelleEvent_NEW, T~"")) %>% arrange(-nf) %>% head(100), 
#        aes(area = nf, fill = type2)) +
#   geom_treemap()+
#   #geom_treemap_text(color="white", place = "centre", size = 15) +
#   scale_fill_manual(values=divergingx_hcl(6, palette="Zissou 1")[c(5,2,4)], name="")+
#   theme(legend.position = c(1-0.91,0.9), 
#         legend.title = element_blank())
#   
# ggsave("treemap.png", g, width=5000, height=1500, scale=0.6, units="px")
```

# Networks

A listers are circles, B listers are crosses. 

```{r}
attr(nodelist, "info") %>% cat

```

```{r}
graph_from_data_frame(e2, directed = F, vertices = nodelist) %>% ecount() %>% paste( "edges") %>% cat
```


```{r test, eval=F}
divyearplot(nodelist  %>% mutate(target=degree),ex=NULL, yl="Raw degree", convert=convertplots)
divyearplot(nodelist  %>% mutate(target=degree, lower=NA, upper=NA), 
            ex=exgenfests, yl="Raw degree", convert=convertplots, splitab=F, 
            networkstats = T)

knitr::knit_exit()
```

```{r, eval=F, echo=F}
# prepare static Image objects, not run

gr = as_tbl_graph(graph_from_data_frame(e2, directed = F, vertices = nodelist))

gm = ggraph(gr,layout="manual", x=nodelist$x, y=nodelist$y  ) + 
  geom_node_point(aes(color=YearEvent, size=ab, shape=ab), stroke=0.9, alpha=0.8) + 
  #geom_node_point(aes(color=ab, shape=ab, size=ab), alpha=0.8, stroke=0.9) + 
  geom_edge_link(aes(color=coloryear, alpha=dist), width=0.2) +
  scale_x_continuous(breaks=2009:2021, expand=expansion(add=0.2))+
  scale_y_continuous( expand=expansion(add=0.2))+
  scale_color_viridis(end=0.9)+
  scale_edge_color_viridis(end=0.9)+
  scale_edge_alpha(range=c(0.08, 0.8))+
  scale_shape_manual(values=abshapes)+
  scale_size_manual(values=c(2.4, 0.5))+
  theme_void()+
  theme(legend.position = 'none', axis.text.x=element_text(),
        plot.background = element_rect(color="white", fill="white")
  )

ggsave("yearnetworkab.png", gm, width=5000, height=3000, scale=0.6, units="px")

# degree instead of umap
# gm = ggraph(gr %E>%  filter(tolibelle %in% c("2015 Berlinale - Berlin IFF", "2021 AFCAE") | fromlibelle %in% c("2015 Berlinale - Berlin IFF", "2021 AFCAE")),layout="manual", x=nodelist$x, y=nodelist$degree  ) +
#   geom_node_point(aes(color=YearEvent, size=ab, shape=ab), stroke=0.9, alpha=0.8) +
#   #geom_node_point(aes(color=ab, shape=ab, size=ab), alpha=0.8, stroke=0.9) +
#   geom_edge_link(aes(color=coloryear, alpha=dist), width=0.2) +
#   scale_x_continuous(breaks=2009:2021, expand=expansion(add=0.2))+
#   scale_y_continuous( expand=expansion(add=0.2))+
#   #coord_cartesian(ylim=c(0,135))+
#   scale_color_viridis(end=0.9)+
#   scale_edge_color_viridis(end=0.9)+
#   scale_edge_alpha(range=c(0.08, 0.8))+
#   scale_shape_manual(values=c(16,3))+
#   scale_size_manual(values=c(2.4, 0.5))+
#   theme_void()+
#   theme(legend.position = 'none',
#         axis.text.x=element_text(),
#         axis.text.y=element_text(),
#         plot.background = element_rect(color="white", fill="white")
#   )
# ggsave("yearnetworkabdegree.png", gm, width=5000, height=3000, scale=0.6, units="px")

# try tree layout

gm = ggraph(gr,layout="manual", 
            x=nodelist$YearEvent+runif(nrow(nodelist), -0.45,0.45), 
            y=layout_as_tree(graph_from_data_frame(e2 %>% filter(dist %in% 0:1), directed = F, vertices = nodelist))[,1] 
            ) + 
  geom_node_point(aes(color=YearEvent, size=ab, shape=ab), stroke=0.9, alpha=0.8) + 
  #geom_node_point(aes(color=ab, shape=ab, size=ab), alpha=0.8, stroke=0.9) + 
  geom_edge_link(aes(color=coloryear, alpha=dist), width=0.2) +
  scale_x_continuous(breaks=2009:2021, expand=expansion(add=0.2))+
  scale_y_continuous( expand=expansion(add=0.2))+
  scale_color_viridis(end=0.9)+
  scale_edge_color_viridis(end=0.9)+
  scale_edge_alpha(range=c(0.08, 0.8))+
  scale_shape_manual(values=abshapes)+
  scale_size_manual(values=c(2.4, 0.5))+
  theme_void()+
  theme(legend.position = 'none', axis.text.x=element_text(),
        plot.background = element_rect(color="white", fill="white")
  )
ggsave("yearnetworktree2.png", gm, width=5000, height=3000, scale=0.6, units="px")


n2 = nodelist %>% left_join(festcountryvecs %>% select(eventlong, eventlat, EventID_VZ), by="EventID_VZ") %>% mutate(xx=eventlong+runif(nrow(.), -5, 5), yy=eventlat+runif(nrow(.), -5, 5))
gm = ggraph(gr, layout="manual", x=n2$xx, y=n2$yy  ) + 
  geom_node_point(aes(color=YearEvent, size=ab, shape=ab), stroke=0.9, alpha=0.8) + 
  geom_edge_link(aes(color=coloryear, alpha=dist), width=0.2) +
  geom_polygon(aes(long, lat, group = group), data=mp, inherit.aes = F, color="gray50", fill=NA, size=0.1)+
  scale_color_viridis(end=0.9)+
  scale_edge_color_viridis(end=0.9)+
  scale_edge_alpha(range=c(0.08, 0.8))+
  scale_shape_manual(values=abshapes)+
  scale_size_manual(values=c(0.9, 0.2))+
  coord_fixed(xlim=c(min(filmcountryvecs$long), max(filmcountryvecs$long)),
              ylim=c(min(filmcountryvecs$lat), max(filmcountryvecs$lat)))+
  theme_void()+
  theme(legend.position = 'none', axis.text.x=element_text(),
        plot.background = element_rect(color="white", fill="white")
  )

ggsave("networkmap.png", gm, width=5000, height=2200, scale=0.6, units="px")





# grid
gr = as_tbl_graph(graph_from_data_frame(e2, directed = F, vertices = nodelist))
g = ggraph(gr ,layout = "grid"  ) +
  geom_node_point(aes(color=YearEvent, size=nf)) +
  #geom_node_text(aes(label=name)) +
  geom_edge_arc(aes(color=coloryear, alpha=dist),  width=0.1, strength=0.04) +
  scale_color_viridis(end=0.9)+
  scale_edge_color_viridis(end=0.9)+
  scale_edge_alpha(range=c(0.15, 0.5))+
  scale_size(0.5, 1.5)+
  theme_void()+
  theme(legend.position = 'none',
        plot.background = element_rect(color="white", fill="white")
  )

ggsave("g.png", g, width=5000, height=5000, scale=0.6, units="px")

```

## Big force-directed network

Leaving out the few unconnected festivals from this one for better layout. Zoomable; hover to see labels, click on nodes to see connections.

```{r}
 visn
```

## As a matrix

Color is overlap between festival programmes, each row is a festival, cells show how much it (relative to itself) overlaps with past and future festivals.

```{r, fig.width=7, fig.width=7}
hm=heatmaplist %>% 
  #group_by(fromyear) %>%  arrange(-overlap, .by_group = T) %>%  mutate(y = as.factor((100*fromyear)+(1:n())) ) %>% 
  mutate(fillweight=log10(weight)) %>% 
  mutate(overlap2 = case_when(overlap==0 ~ NA, T~overlap)) %>% 
         mutate(tool=paste0(fromlibelle,"\n",  
                            tolibelle, 
                            "\nn shared=",weight,
                            "\n% overlap=",overlap, "\ntime dist=",dist ))
  
hmy = hm %>% # year labels
        arrange(tolibelle) %>% 
          filter(toyear>2011, fromyear>2011) %>% 
          group_by(toyear ) %>% 
          filter(1:n()==round(n()/2)) %>% 
  mutate(fromlibelle=tolibelle)


# {ggplot(hm , 
#        aes(tolibelle, fromlibelle, fill=overlap, text=tool))+
#   coord_cartesian(expand=F)+
#   geom_tile(size=0)+
#   geom_text(aes(label=toyear, x=0), data=hmy, size=2, hjust=0,vjust=1, angle=90)+
#   geom_text(aes(label=toyear,x=fromlibelle, y=0), data=hmy, size=2, vjust=0)+
#   #scale_fill_viridis_c(end=0.9, na.value = "white")+
#   #scale_fill_gradientn(colors = cls, na.value = "white", trans="log10", name="log\nstrength")+
#   scale_fill_gradientn(colors = c("white",cls), na.value = "white",  name="overlap")+
#   theme_bw()+
#     theme(legend.position = 'none', 
#       panel.border = element_blank(),
#       panel.grid.minor.x = element_blank(),
#       plot.background = element_rect(color="white", fill="white"),
#       axis.title = element_blank(),
#       axis.text = element_blank(), # element_text(size=3),
#       axis.ticks = element_blank()
#      # axis.text.x = element_text(angle=90, hjust=1, vjust=1)
#     )} %>% ggplotly(tooltip = "text")

fig_heatmap =  ggplot(hm %>% mutate(w=rescale(overlap2,to=c(1,1.3))) , 
       aes(tolibelle, fromlibelle, 
         fill=overlap2, text=tool))+
  coord_cartesian(expand=F)+
  geom_tile(aes(height=w, width=w), size=0)+
  geom_text(aes(label=toyear, x=0), data=hmy, hjust=0,vjust=1, angle=90,size=2.5)+ 
            #color=viridis_pal(end = 0.9)(13))+
  geom_text(aes(label=toyear,x=fromlibelle, y=0), data=hmy,vjust=0, size=2.5)+
  
  #scale_fill_viridis_c(end=0.9, na.value = "white")+
  #scale_fill_gradientn(colors = cls, na.value = "white", trans="log10", name="log\nstrength")+
  # scale_fill_viridis_c(direction=-1,na.value = "white", option="magma", trans="log10", name="log\nstrength")+
  scale_fill_gradientn(colors = matcols, na.value = "transparent",  name="Overlap %")+
  annotate("text", -Inf, Inf, hjust=-2, vjust=1, label="C", fontface='bold')+
  theme_bw()+
    theme(legend.position = c(0.94,0.22), 
      panel.border = element_blank(),
      panel.grid = element_blank(),
      plot.background = element_rect(color="white", fill="white"),
      axis.title = element_blank(),
      axis.text = element_blank(), # element_text(size=3),
      axis.ticks = element_blank()
    )

gg(fig_heatmap, convertplots)


```




## Temporally arranged network

![](C:/Users/Andres/Documents/yearnetworkab.png)



```{r, eval=F}
# Interactive nodes yearwise, with hover labels:
gmp=ggplot(nodelist, aes(x, y,color=YearEvent,text=tool, shape=ab, size=ab))+
  geom_point( alpha=0.8) + 
  scale_x_continuous(breaks=2009:2021)+
  scale_color_viridis_c(end=0.9)+
  scale_shape_manual(values=abshapes)+
  scale_size_manual( values=c(2, 1))+
  theme_void()+
  theme(legend.position = 'none', axis.text.x=element_text(),
        plot.background = element_rect(color="white", fill="white")
  )
plotly::ggplotly(gmp, tooltip="text")

```

Network laid on on the world map according to event locations:

![](C:/Users/Andres/Documents/networkmap.png)

# Network statistics

## Degree

Keep in mind that degree stats should *only* be interpreted for the "middle" of the database in terms of years - festivals in the earilest as well as latest years have lower degree simply because there is nothing/not much to link to in the past/future that is not in the database, plus early years of the database had considerably less festivals in it.

### Raw values

(correlates moderately with festival entry size)

```{r}
divyearplot(nodelist  %>% mutate(target=degree),ex=NULL, yl="Raw degree", convert=convertplots)
divyearplot(nodelist  %>% mutate(target=degree, lower=NA, upper=NA), 
            ex=exgenfests, yl="Raw degree", convert=convertplots, splitab=F, 
            networkstats = T)


ggplot(nodelist %>% filter(YearEvent%in% 2015:2019) %>% 
           group_by(ab) %>% arrange(-degree, .by_group = T) %>% 
           mutate(n=1:n()),
         #group_by(degree) %>% mutate(n=n()),
         aes( degree,  text=tool, fill=ab))+
  #geom_point(size=0.5)+
  geom_histogram(binwidth = 1)+
  #scale_y_log10()+
  #scale_x_log10()+
  #scale_y_reverse()+
  scale_fill_manual(values=abcols)+
  scale_y_continuous(breaks= pretty_breaks())+
  # annotation_logticks(sides="b", size=0.2,
  #                     short = unit(.5,"mm"),
  #                     mid = unit(1,"mm"),
  #                     long = unit(2,"mm"))  +
  labs(x="Degree", y="Frequency")+
  theme_bw()+
  facet_wrap(~ab, nrow = 2, scale="free_y")+
  theme(legend.position = "none")
# ggplotly(g, tooltip="text")
```



```{r, eval=F}
# Without any links, degree=0:
nodelist %>% filter(degree==0)
```





##  Degree vs strength

```{r}


g = ggplot(nodelist, aes(degree, strength, text=tool, color=ab, size=nf))+
  geom_point(alpha=0.7)+
  scale_x_log10()+
  scale_y_log10()+
  annotation_logticks(sides="bl", size=0.2,
                      short = unit(.5,"mm"),
                      mid = unit(1,"mm"),
                      long = unit(2,"mm"))  +
  scale_color_manual(values=abcols)+
  scale_shape_manual(values=abshapes)+
  scale_size_continuous(range=c(0.1,4))+
  theme_bw()+
  theme(legend.position = "none", panel.grid.minor = element_blank())+
  facet_wrap(~ab, nrow = 1)
 ggplotly(g, tooltip="text") 
  
```

### Normalized degree

Degree normalized by dividing with the log10 number of unique films in a festival entry; roughly on a similar scale to the raw values, but almost decorrelated from the entry size and therefore comparable between festivals, and between iterations of a festival series.

```{r}
divyearplot(nodelist  %>% mutate(target=lndegree),ex=NULL, yl="Degree normalized by entry size", convert=convertplots)
divyearplot(nodelist  %>% mutate(target=lndegree, lower=NA, upper=NA), 
            ex=exgenfests, yl="Degree normalized", convert=F, splitab=F, 
            networkstats = T)


```







# Thematic or content types

```{r}
cat(attr(festgenrevecs, "info"))
```


Latent space of content/genre tag similarities is inferred directly from the data, based on content type co-occurrence statistics.

## Big UMAP

```{r}

### curated map



#ux=prcomp(allvecs %>% select(starts_with("V")), center  = T, scale. = T)$x[,1:2] %>% as.data.frame() %>%cbind(allvecs %>% select(-starts_with("V"))) # %>% filter(PC1< 1, PC2 < 1, PC2 > -1) 

ggplot( mapping=aes(V1, V2, color=colorgenre))+
  geom_point(aes(shape=ab, text=tool), data=ugenre %>% filter(type=="festival"), size=2, fill=NA, alpha=0.6)+
  # geom_shadowtext(aes(label=firstkind, size=sizegen), 
  #                 data=ugenre %>% filter(type %in% c("genre")), 
  #                 bg.color="white", alpha=0.5, hjust=0, show.legend = FALSE
  #             # ,max.overlaps=100, box.padding = 0, point.padding = 0, min.segment.length = 999, force_pull=0.5, max.time = 2
  #             )+
  geom_point( data=ugenre %>% filter(type=="film"), size=0.1, fill=NA,show.legend = FALSE)+
  geom_text_repel(aes(label=event, size=sizegen %>% log), 
                  data=ugenre %>% filter(type %in% c("genre", "film")), 
            lineheight=0.49,
            alpha=1, hjust=0, 
            #bg.color="white",  
            show.legend = FALSE, max.overlaps=100, box.padding = 0, point.padding = 0, min.segment.length = 999, force_pull=0.5, max.time = 2)+
    
  scale_size(range=c(2.5,6), guide="none")+
  scale_shape_manual(values=abshapes, name="Festival\ntype")+
  scale_color_manual(values=sixgcols, name="Main\ngenre")+
  theme_void()+
  theme(#legend.position = 'none',
        plot.background = element_rect( fill="white")
  )+
    labs(title="Content type common latent space, UMAP projection")+
  NULL


gg(g, convertplots)

```



## Change over time

As difference between consequtive years, in festivals with at least 11 iterations. Confidence interval interpretation same as above.

```{r}
ggplot(genrechangevals %>% group_by(libelleFestival_NEW_VZ) %>%
         filter(n_distinct(EventID_VZ)>=10),
       aes(YearEvent, dif, ymin=diflower, ymax=difupper))+
  geom_point()+
  geom_line()+
  geom_errorbar(width=0)+
  facet_wrap(~libelleFestival_NEW_VZ)+
  theme_bw()

#ggplot(genrechangevals, aes(indiv, dif))+geom_point()
```

------------------------------------------------------------------------


```{r, eval=F}

# Pipeline plots

mains=levels(festgenrevecs$colorgenre) %>% head(-1)
others = setdiff(
  table( attr(festgenrevecs, "filmfestvecs")$firstfilmkind) %>% sort(decreasing = T) %>% names(),
  mains)

tops = attr(festgenrevecs, "tops") %>% 
  left_join(festgenrevecs %>% filter(!duplicated(EventID_VZ)), by="EventID_VZ") %>% 
  select(txtKind, s, EventID_VZ, libelleFestival_NEW_VZ, YearEvent, LibelleEvent_NEW_VZ) %>% 
  filter(libelleFestival_NEW_VZ %in% exgenfests) %>% 
  filter(YearEvent==2019) %>% 
  ungroup() %>% 
  mutate(colorgenre2=fct_relevel(txtKind, 
                                c(mains, others) %>% rev))
  

# festival illustration squares.
ggplot(tops, aes( y=s,x=colorgenre2, fill=colorgenre2))+
  geom_bar(stat="identity", color=NA)+
  scale_fill_manual(values=
                      c(sixgcols %>% head(-1),
                        gray.colors(
                          length(unique(tops$colorgenre2))-
                            length(mains),
                          start=0.5, end=0.7
                          )) %>% rev)+
  coord_cartesian(expand = 0)+
  scale_x_discrete(breaks=mains)+
  theme_void()+
  theme(axis.title = element_blank(),
        legend.position = "none",
        panel.border  = element_rect(linewidth=0.5, color="gray10", fill=NA), 
        strip.text = element_text(size=15),
        plot.margin = margin(3,3,3,3)
        )+
  facet_wrap(~libelleFestival_NEW_VZ, strip.position="top",  nrow=2)
  
  #filter(grepl("Tallinn", LibelleEvent_NEW_VZ, ignore.case = T)) %>% count(LibelleEvent_NEW_VZ)

#festvecs %>% filter(LibelleEvent_NEW_VZ %in% "Tallinn_Black_Nights_IFF_2012") %>% select(starts_with("V"))

ggplot(attr(genlat, "latmap"), aes(V1,V2,label=txtKind,size=n))+geom_text()+
  scale_size(range=c(1.5,5))+
  theme_void()+
  theme(legend.position = "none",
        panel.border = element_rect(fill=NA),
        plot.margin = margin(1,1,1,1)
        )
ggsave("fig_sup_latentmap.pdf", width=9, height=5, scale=0.6)




ggplot( mapping=aes(V1, V2, color=colorgenre))+
  geom_point(aes(shape=ab, text=tool), data=ugenre %>% filter(type=="festival"), size=1, fill=NA, alpha=0.3, shape=16)+
  geom_point(aes(fill=colorgenre, text=tool), data=ugenre %>% 
               filter(type=="festival", event %in% tops$LibelleEvent_NEW_VZ), 
             size=4,  alpha=1, shape=21, color="black")+
  geom_text_repel(aes(label=event %>% gsub("_", "",.)), data=ugenre %>% filter(type=="festival", event %in% tops$LibelleEvent_NEW_VZ), 
            size=4,  alpha=1, hjust=1.1, bg.color="white")+
  #geom_point( data=ugenre %>% filter(type=="film") %>% slice_sample(n = 3), size=0.1, fill=NA,show.legend = FALSE)+
  geom_text_repel(aes(label=event, size=log(sizegen+100)), 
                  data=rbind(
                    ugenre %>% filter(type %in% c("genre")) %>% arrange(-sizegen) %>% head(6),
                    ugenre %>% filter(type %in% c("film")) %>% group_by(colorgenre) %>% 
                      slice(1) %>% head(4)
                  )
                    , 
            lineheight=0.6,
            alpha=1, hjust=0, 
            bg.color="white",  
            show.legend = FALSE, max.overlaps=100, box.padding = 0, point.padding = 0, min.segment.length = 999, force_pull=0.5, max.time = 2)+
    
  scale_size(range=c(2.5,6), guide="none")+
  scale_color_manual(values=sixgcols, name="")+
  scale_fill_manual(values=sixgcols, name="")+
  theme_void()+
  theme(#legend.position = 'none',
        plot.background = element_rect( fill="white"),
        legend.position = "none"
  )+
  NULL


```

## Diversity

The diversity values are scaled into a range of \[0,1\], using the largest possible distance in the latent genre space as the scaling value (and multiplied by 2 in the case of internal diversity, as it's comparison to internal mean), and are thus interpretable.

-   0 internal diverity: all films are of the same metadata type
-   1 internal: the films are as different as can be
-   0 external: festival looks exactly like the ecosystem grand mean
-   1 external: festival is as distant from the grand mean as possible in the given latent space.

Also, note the error bars: they represent 95% confidence intervals from a nonparametric bootstrapping, i.e. the true mean value (the dots) are likely to be within the given range. Smaller festival samples and festivals with more variation around the mean for a given statistic therefore have larger bar ranges.

```{r}
div2plot(festgenrevecs, ex=NULL, convert=convertplots, genrecols = sixgcols)


divyearplot(festgenrevecs  %>% mutate(target=indiv),
            ex=NULL, yl="Internal genre diversity", convert=convertplots, networkstats = F)
divyearplot(festgenrevecs  %>% mutate(target=indiv, lower=ilower, upper=iupper), 
            ex=exgenfests, yl="Internal genre diversity", convert=convertplots, splitab=F, networkstats = F)


sysplots(attr(festgenrevecs,"sysdivs"), yl="System internal genre diversity")

divyearplot(festgenrevecs  %>% mutate(target=exdiv),ex=NULL, yl="External genre diversity", convert=convertplots, networkstats = F)

divyearplot(festgenrevecs  %>% mutate(target=exdiv, lower=elower, upper=eupper), 
            ex=exgenfests, yl="External genre diversity", convert=convertplots, splitab=F, networkstats = F)



```



<br>

# Festival profiles by film age

Shows mean difference between event year and production years of shown films. Unit on both axes is years of difference. Some noise added on x-axis due to lots of overlapping values from the integer calculations. Zoom in to see where most of the datapoints are. High sd means festival shows a mix of newer and older films.

```{r}
{ggplot(yeardiffvals ,#%>% filter(yeardif> -100, yearsd < 25),
        aes(yeardif, yearsd, text=tool, color=ab, shape=ab))+
  geom_point(size=0.5, alpha=0.7, position=position_jitter(0.3,0))+
  labs(y="Standard deviation", x="Mean time distance between event and production") +
  scale_color_manual(values=abcols)+
    scale_shape_manual(values=abshapes)+
    scale_size_manual(values=c(0.8,0.4))+
    theme_bw()
    } %>% gg()

divyearplot(yeardiffvals  %>% mutate(target=yearmean),ex=NULL, yl="Time distance", convert=F, networkstats = F)

divyearplot(yeardiffvals  %>% mutate(target=yearmean, lower=yearmean-yearsd, upper=yearmean+yearsd), 
            ex=exgenfests, yl="Time distance", convert=convertplots, splitab=F, networkstats = F)


```

NB: here the bars are standard deviation, not confidence intervals. Note how Cannes seesaws between showing newer and older (retrospective?) films. Some show films from the future (final production year is later than event).

<br>

## Comparison with genre internal diversity

```{r}
div2plot(yeardiffvals %>% select(EventID_VZ,yeardif, tool) %>% left_join(festgenrevecs, by="EventID_VZ") %>% 
           mutate(exdiv=yeardif, tool=paste0(tool.x, "\n", tool.y)), ex=NULL, convert=T, xlab="Mean difference between event and production", genrecols = sixgcols)
```

------------------------------------------------------------------------

# Languages

```{r}
cat(attr(festlangvecs, "info"))
```

## Big UMAP

```{r}

{ggplot( mapping=aes(V1, V2, color=colorgenre))+
  geom_text(aes(V1, V2, color=colorgenre,label=libelleFestival_NEW_VZ), 
            data=ulang %>% sample_n(30), size=3, show.legend = F, inherit.aes = F, alpha=0.9)+
  geom_point(aes(shape=ab, text=tool), data=ulang , size=2, fill=NA)+
  scale_size(range=c(4,10), guide="none")+
  scale_shape_manual(values=c(16,3), name="Festival\ntype")+
  scale_color_manual(values=langcols, name="Main\nlanguage",
                     breaks=levels(ulang$colorgenre)
                     )+ # add breaks if multiple geoms
  theme_void()+
  theme(#legend.position = 'none',
    plot.background = element_rect( fill="white")
  )+
  NULL}  %>% gg(convertplots)
```


## * Diversity

Again, the diversity values are scaled into a range of \[0,1\], using the largest possible distance in the latent space (the interlanguage distances) as the scaling value, and are thus interpretable:

-   0 internal diverity: all films are of the same metadata type
-   1 internal: the films are as different as can be
-   0 external: festival looks exactly like the ecosystem grand mean
-   1 external: festival is as distant from the grand mean as possible in the given latent space.

```{r}

div2plot(festlangvecs, ex=NULL, convert=convertplots,  genrecols = langcols)

divyearplot(festlangvecs  %>% mutate(target=indiv),ex=NULL, yl="Internal language diversity", convert=convertplots, networkstats = F)
divyearplot(festlangvecs  %>% mutate(target=indiv, lower=ilower, upper=iupper), 
            ex=exlangfests, yl="Language diversity", convert=convertplots, splitab=F, networkstats = F)

sysplots(attr(festlangvecs,"sysdivs"), yl="System internal language diversity")


divyearplot(festlangvecs  %>% mutate(target=exdiv),
            ex=NULL, yl="External language diversity", convert=convertplots, networkstats = F)
divyearplot(festlangvecs  %>% mutate(target=exdiv, lower=elower, upper=eupper), 
            ex=exlangfests, yl="External language diversity", convert=convertplots, splitab=F, networkstats = F)


```

------------------------------------------------------------------------

<br> <br>




# Geography

```{r}
cat(attr(festcountryvecs, "info"))
```

Note: since production location is at the precision of country, I'm using the coordinates of capital cities for all calculations here, with the exception of the US, where Los Angeles coordinates are used.

## * Diversity

All in kilometers - these could in principle also be scaled (by the circumference of the globe divided by 2), but are probably more informative as real-valued statistics.

```{r}
div2plot(festcountryvecs, ex=NULL, convert=convertplots,  genrecols = sixcols)
```

```{r}
divyearplot(festcountryvecs  %>% mutate(target=indiv),ex=NULL, yl="Internal geo diversity", convert=convertplots, networkstats = F)
divyearplot(festcountryvecs  %>% mutate(target=indiv, lower=ilower, upper=iupper), 
            ex=exgeofests, yl="Internal geo diversity", convert=convertplots, splitab=F, networkstats = F)

sysplots(attr(festcountryvecs,"sysdivs"), yl="System internal geo diversity")


divyearplot(festcountryvecs  %>% mutate(target=exdiv),
            ex=NULL, yl="External geo diversity", convert=convertplots, networkstats = F)
divyearplot(festcountryvecs  %>% mutate(target=exdiv, lower=elower, upper=eupper), 
            ex=exgeofests, yl="External geo diversity", convert=convertplots, splitab=F, networkstats = F)

```

## Latent centers of festivals

Each dot is the average production-country coordinates of the films of one festival (weighted, if coproduction). Latent centre is the big + , Cannes is the black dot. I removed the geographical borders/continents, as it may motivate the false interpretations that festivals take place in the sea; but added some geo labels to ease orientation. Obviously no dimension reduction is needed as the space is already plottable on a 2-dimensional projection (by longitude & latitude), albeit technically being a sphere for calculation purposes.

```{r}
labs=tribble(
  ~id, ~long, ~lat,
  "USA", -90, 40,
  "Canada", -100, 55,
  "Latin\nAmerica", -65, 1,
  "Brazil", -35,-11,
  "Africa", 27, 9,
  "UK", -1, 53,
  "Europe", -4, 48,
  "Russia", 54,59,
  "Nordics", 26,63,
  "Middle\nEast",50, 25,
  "India",  85,16,
  "Australia",135,-25,
  "China", 115, 30,
  "Japan", 143, 38
)
g = ggplot()+
  #coord_fixed(xlim=c(min(filmcountryvecs$long), max(filmcountryvecs$long)),ylim=c(min(filmcountryvecs$lat), max(filmcountryvecs$lat)))+
  #geom_bin2d(aes(long, lat), filmcountryvecs, bins=70, alpha=0.9, color="gray90")+
  # geom_point(aes(eventlong, eventlat), data=
  #              festcountryvecs %>% 
  #              filter(LibelleEvent_NEW_VZ=="Berlinale_-_Berlin_IFF_2018"),
  #            alpha=0.5, color="navy"
  #            )+
  #stat_density2d(aes(long, lat, fill = ..level..),filmcountryvecs, geom = "polygon", bins=100)+
  #geom_polygon(aes(long, lat, group = group), data=mp, inherit.aes = F, color="gray50", fill=NA, size=0.3)+
    #geom_point(aes(long, lat), festcountryvecs %>% filter(libelleFestival_NEW_VZ %in% examples), fill="black",color="transparent",stroke=NA, size=1, alpha=1, shape=21)+
  geom_text(aes(long, lat, label=id), data=labs, inherit.aes = F, lineheight=0.6, hjust=1, size=3.5)+
  annotate("point", x=attr(festcountryvecs, "latentcentre")[1], y=attr(festcountryvecs, "latentcentre")[2], shape=3, size=6, stroke=1.2)+ # centre
  geom_point(aes(long, lat, color=colorgenre, shape=ab,size=ab, text=tool), festcountryvecs, alpha=0.7)+
  annotate("point", x=7.012800, y=43.551300)+   # cannes
  #scale_size(range=c(0.1,1))+
    scale_shape_manual(values=abshapes, name="")+
    scale_color_manual(values = sixcols, name="Main\nproduction\ncountry")+
    scale_size_manual(values = c(1.8,1.3))+
    scale_x_continuous(breaks=seq(-125,150,25), expand=c(0,10))+
    scale_y_continuous(limits = c(-26, 69))+
  #scale_fill_gradientn(colors=c("gray99", sequential_hcl(palette="Lajolla", 50)) %>% darken(0.2) )+
  theme_minimal()+
  labs(x="Longitude", y="Latitude")+
  theme(#legend.position = 'none',
        plot.background = element_rect(fill="white"),
        panel.border = element_rect(color="black", fill=NA)
  )
if(convertplots){
  g %>%  ggplotly() #%>% {.$x$data[[1]]$hoverinfo="none"; .$x$data[[2]]$hoverinfo="none";.} 
} else {
  g
}
 
```

For reference, the actual host contries of the festivals: since these overlap a lot, they are scattered a bit (but internally still located at capital city coordinates, regardless of actual host city)

```{r}

{ggplot()+
  coord_fixed(#xlim=c(min(filmcountryvecs$long+1), max(filmcountryvecs$long)+1),
               #   ylim=c(min(filmcountryvecs$lat-1), max(filmcountryvecs$lat)+1)
    )+
  geom_polygon(aes(long, lat, group = group), data=mp, inherit.aes = F, color="gray50", fill=NA, size=0.1)+
  geom_point(aes(eventlong, eventlat, shape=ab, color=ab, text=tool), festcountryvecs,alpha=0.8, position=position_jitter(5,5))+
  scale_size_manual(values=c(0.8,0.4))+
    scale_shape_manual(values=abshapes)+
    scale_color_manual(values = abcols)+
  #scale_fill_gradientn(colors=c("gray99", sequential_hcl(palette="Lajolla", 50)) %>% darken(0.2) )+
  theme_void()+
  theme(legend.position = 'none',
        plot.background = element_rect(fill="white"),
        panel.border = element_rect(color="black", fill=NA)
  )} %>%  ggplotly() %>% {.$x$data[[1]]$hoverinfo="none";.} 

```

## Distance between event host country and its latent (film-based) geographical centre

In kilometers; "eventdist" on the tooltip.

```{r}


divyearplot(festcountryvecs  %>% mutate(target=eventdist),ex=NULL, yl="distance between latent centre and host country", convert=convertplots, networkstats = F)
divyearplot(festcountryvecs  %>% mutate(target=eventdist, lower=edlower, upper=edupper), 
            ex=exgeofests, yl="distance", convert=convertplots, splitab=F, networkstats = F)

```

```{r, eval=F}
## Internal geo diversity vs betweenness-diversity
# festcountryvecs %>% left_join(nodelist %>% select(EventID_VZ, nbetweenness), by="EventID_VZ") %>% 
#   mutate(exdiv=nbetweenness) %>% 
#   div2plot( ex=NULL) %>% 
#   layout(xaxis = list(title="betweenness normalized by entry size (n films)"),
#          yaxis = list(title="internal geo diversity normalized by entry size (n films)")
#          )

```



## Distance between event and film production 

Events in Europe, colored by average distance between event location and the production location of the programmed events

```{r}
# fc = festcountryvecs %>% filter(eventlong > -10, eventlong < 30, eventlat > 35, eventlat < 60)
# 
# fcvals = fc %>% mutate(txtCountryEvent_VZ=case_when(txtCountryEvent_VZ=="uk"~"united kingdom", T~txtCountryEvent_VZ)) %>% group_by(txtCountryEvent_VZ) %>% summarise(val=mean(eventdist,na.rm=T)) %>% ungroup %>% rename(id=txtCountryEvent_VZ) %>% select(id, val)
# mp2 = mp %>% mutate(id=tolower(id)) %>% left_join(fcvals, by="id")
  
# attempt to scatter, but still all on capitals, not great.
  # mutate(gr = paste(eventlong, eventlat)) %>% group_by(gr) %>%
  # mutate(ng = log2(n())) %>% 
  # mutate(eventlong2=case_when(
  #   n()<= 3 ~eventlong, 
  #   T~eventlong+
  #     (rep( seq(-floor(ng[1])/2, ceiling(ng[1])/2, length.out=ceiling(ng[1])), each=round(ng[1]) )[1:n()]/3 )
  #   ) ) %>% 
  # mutate(eventlong2=case_when(is.na(eventlong2)~eventlong, T~eventlong2))

# ggplot()+
#   coord_fixed(xlim=c(min(fc$eventlong+1), max(fc$eventlong)+1),
#               ylim=c(min(fc$eventlat-1), max(fc$eventlat)+1)
#     )+
#   geom_polygon(aes(long, lat, fill=val, group = group), data=mp2, inherit.aes = F, color="gray50",  size=0.1)+
#   #geom_beeswarm(aes(eventlong, eventlat, shape=ab, color=ab, text=tool), fc,alpha=0.8, groupOnX = F, cex = 0.1) + #,position=position_jitter(1,1))
#     theme_void()+
#   theme(legend.position = 'none',
#         plot.background = element_rect(fill="white"),
#         panel.border = element_rect(color="black", fill=NA)
#   )



{ggplot()+
  coord_fixed(#xlim=c(min(filmcountryvecs$long+1), max(filmcountryvecs$long)+1),
               #   ylim=c(min(filmcountryvecs$lat-1), max(filmcountryvecs$lat)+1)
    )+
  geom_polygon(aes(long, lat, group = group), data=mp, inherit.aes = F, color="gray50", fill=NA, size=0.1)+
  geom_point(aes(eventlong, eventlat, shape=ab, color=ab, text=tool), festcountryvecs,alpha=0.8, position=position_jitter(5,5))+
  scale_size_manual(values=c(0.8,0.4))+
    scale_shape_manual(values=abshapes)+
    scale_color_manual(values = abcols)+
  #scale_fill_gradientn(colors=c("gray99", sequential_hcl(palette="Lajolla", 50)) %>% darken(0.2) )+
  theme_void()+
  theme(legend.position = 'none',
        plot.background = element_rect(fill="white"),
        panel.border = element_rect(color="black", fill=NA)
  )} %>%  ggplotly() %>% {.$x$data[[1]]$hoverinfo="none";.} 

```


##  Comparison of language and production country (internal) diversity

Interestingly correlates only weakly (R2=0.096, p\<0.0001).

```{r}
lg = left_join(festlangvecs %>% select(-exdiv), 
          festcountryvecs %>% select(EventID_VZ, indiv,tool) %>% rename(exdiv=indiv, tool2=tool), by="EventID_VZ") %>% 
  mutate(tool=paste("Lang:",tool,"\nGeo:",tool2)) 
div2plot(lg, ex=NULL, convert=convertplots, xlab="Geo internal diversity", ylab="Language internal diversity",  genrecols = langcols)
```


<br>

# * Gender diversity

Using producer and director first name gender, where identifiable, to calculate ratio in a film; festivals are means of film ratios.

```{r}
cat(attr(festrolevecs, "info"))
```


```{r}

g=ggplot(festrolevecs, mapping=aes(ratiopf, ratiodf, color=ratiof, shape=ab, size=ab, text=tool))+
  geom_vline(xintercept = 0.5)+
  geom_hline(yintercept = 0.5)+
  geom_point()+
  scale_size_manual(values =c(1.4,0.8)*1.2, guide="none")+
  scale_shape_manual(values=abshapes, name="Festival\ntype")+
  scale_color_gradientn(colours =rolecols, name="Female\nto male\nratio\namong\nproducers\n&directors", limits=c(0,1))+
  theme_bw()+
  theme(#legend.position = 'none',
        plot.background = element_rect( fill="white")
  )+
  labs(x="Producers", y="Directors")+
  NULL

if(convertplots){
  gg(g)
} else {g}




```
(the cross is 50-50 lines)

```{r}
divyearplot(festrolevecs  %>% mutate(target=ratiof),ex=NULL, yl="Average % of female producers & directors", convert=T, networkstats = F, ylims=c(0,1)) 

sysplots(attr(festrolevecs,"sysdivs"), yl="System-wide weighted F2M ratios")+lims(y=c(0.2,0.45))

divyearplot(festrolevecs  %>% mutate(target=ratiof, lower=rfminboot, upper=rfmaxboot),
            ex=exgenfests, yl="Female to male ratio", convert=convertplots, splitab=F, networkstats = F, ylims=c(0,1))

```

These are now also bootstrapped 95% confidence intervals - the upper and lower take into account the uncertainty of the name-to-gender algorithm when bootstrapping the intervals. This of course makes for much larger intervals/more uncertainty, but that's the point, the samples are small *and* the ratios inside the samples are uncertain because some names cannot be desiced as M or F.

In contract to previous result, for example the wide interval around the last Hot Docs reflects its small entry size: it looks like it has dropped at face value, but it's hard to be certain, as the sample is much smaller (and of course we don't know if it's because smaller festival or smaller entry). To further illustrate, it would be difficult to claim change in any of the 4 examples here, as all intervals overlap by a large margin.


------------------------------------------------------------------------

<br> <br> <br>

# Example questions

## What predicts linkage/flow between festivals

Simple binomial logistic regression model predicting linkage (at least 1 film shared between a pair of festivals) by the similarity of their metadata (no control for festival series here yet). In short, all the predictors are significant (likely non-random).

-   Event time distance is more of a control, as we know films circulate for a few years usually (the negative $\beta$ coefficient estimate means that the more the two festivals are apart in time, the less likely they are to share films - makes sense).
-   The class categorical variable baseline is that the pair is of different type, so if both are A and A, they are more likely to share a film; if both are B, then they are less likely to share (note the imbalance though, theres more all sorts of B fests)


```{r}
library(rms)
options(scipen=999)
# linkdat = linkdat %>% mutate(class2 = case_match(class, ))
table(linkdat$linked)
m = glm(linked~timedist+ eventdist+ class ,family = "binomial", 
        data=linkdat %>% select(-weight) %>% {.[complete.cases(.),]} %>% 
      mutate(class2=relevel(as.factor(class), "_bothBB"))
    ) 

m %>% summary %>% print

cbind(m$coefficients,
      m$coefficients %>% exp,
      round(summary(m)$coefficients[,"Pr(>|z|)"], 4))





lrm(linked~timedist+ eventdist+ class , data=linkdat)
# glm(linked~timedist+ eventdist* class ,family = "binomial", 
#         data=linkdat %>% select(-weight) %>% {.[complete.cases(.),]} %>% 
#       mutate(class2=relevel(as.factor(class), "_bothBB"))
#     ) %>% summary %>% print

# 151526 + 11780 



```

 

##  What predicts number of shared films

Or strength of edges, for festivals that share at least 2 films. Poisson regression, since it's counts, and loglinear. Interpretation similar to above, here negative coefficient estimate means negative, positive means positive correlation to number of shared films.

```{r}
m = glm(weight~timedist+eventdist+class, 
        data=linkdat %>% filter(weight>0) %>% {.[complete.cases(.),]},
    family = poisson(link = "log")
    ) 
m %>% summary %>% print

linkdat %>% filter(weight>0) %>% nrow
# Mcfadden's:
1 - ( 
      as.numeric(logLik(glm(weight~timedist+eventdist+class, 
        data=linkdat %>% filter(weight>0) %>% {.[complete.cases(.),]},
    family = poisson(link = "log")))) /
      
      as.numeric(logLik(glm(weight~1, 
        data=linkdat %>% filter(weight>0) %>% {.[complete.cases(.),]},
    family = poisson(link = "log")))) 
      )

cbind(m$coefficients,
      m$coefficients %>% exp, 
      round(summary(m)$coefficients[,"Pr(>|z|)"], 4))


```
   
   
This can also be thought of as a directed network, and we can model how much the prorgamme of one festivals duplicated the other; this is just a linear regression model. Temporal distance is relative here too. Here links both ways are included, hence more degrees of freedom. 

```{r}
lm(overlap~timedist+eventdist+class, 
        data=linkdat2
    ) %>% summary %>% print
```





## Compare all festival metrics + Is sundance more like A or B?

```{r}

comparativeplots=function(vecs, xf="Sundance", xtarget, yl  ){
  vecs=vecs %>% rename(target={{xtarget}})
  ggplot(vecs %>% filter(!grepl(xf, LibelleEvent_NEW_VZ)) ,
       aes(y=target, x=ab, fill=ab, color=ab))+
  geom_violin(alpha=0.7)+
  stat_summary(na.rm=T)+
  geom_point(data=vecs %>% filter(grepl(xf, LibelleEvent_NEW_VZ)), shape="-",
             position=position_nudge(x=-0.5), size=5, color="black")+
  scale_fill_manual(values=abcols)+
  scale_color_manual(values=abcols)+
  theme_bw()+
  theme(legend.position = "none",
        axis.title.x=element_blank())+
    labs(y=yl)
}
  
comparativeplots(nodelist, xtarget="lndegree", yl="norm. degree centrality")+
#comparativeplots(nodelist, xtarget="nbetweenness", yl="norm betweenness")+
comparativeplots(festgenrevecs, xtarget="indiv", yl="internal genre diversity")+
comparativeplots(festgenrevecs, xtarget="exdiv", yl="external genre diversity")+
comparativeplots(festcountryvecs, xtarget="indiv", yl="internal geo diversity")+
comparativeplots(festcountryvecs, xtarget="exdiv", yl="external geo diversity")+
comparativeplots(festcountryvecs, xtarget="eventdist", yl="host to latent centre distance")+
comparativeplots(festlangvecs, xtarget="indiv", yl="internal lang diversity")+
comparativeplots(festlangvecs, xtarget="exdiv", yl="external lang diversity")+
  plot_layout(nrow=2)


```

------------------------------------------------------------------------

<br> <br>

# Appendix

## Genre (content type) latent space, UMAP dimension reduction.

```{r}
ggplot(attr(genlat, "latmap"), aes(V1,V2,label=txtKind,size=n))+geom_text()+
  scale_size(range=c(1.5,5))+
  theme_void()+
  theme(legend.position = "none",
        panel.border = element_rect(fill=NA)
        )

 
```


# Plots for paper

## Networks

```{r paper1, eval=F}
# for paper

hm=heatmaplist %>% 
  #group_by(fromyear) %>%  arrange(-overlap, .by_group = T) %>%  mutate(y = as.factor((100*fromyear)+(1:n())) ) %>% 
  mutate(fillweight=log10(weight)) %>% 
  mutate(overlap2 = case_when(overlap==0 ~ NA, T~overlap)) %>% 
         mutate(tool=paste0(fromlibelle,"\n",  
                            tolibelle, 
                            "\nn shared=",weight,
                            "\n% overlap=",overlap, "\ntime dist=",dist ))
  
hmy = hm %>% # year labels
        arrange(tolibelle) %>% 
          filter(toyear>2011, fromyear>2011) %>% 
          group_by(toyear ) %>% 
          filter(1:n()==round(n()/2)) %>% 
  mutate(fromlibelle=tolibelle)

fig_heatmap =  ggplot(hm %>% mutate(w=rescale(overlap2,to=c(1,1.3))) , 
       aes(tolibelle, fromlibelle, 
         fill=overlap2, text=tool))+
  coord_cartesian(expand=F)+
  geom_tile(aes(height=w, width=w), size=0)+
  geom_text(aes(label=toyear, x=0), data=hmy, hjust=0,vjust=1, angle=90,size=2.5)+ 
            #color=viridis_pal(end = 0.9)(13))+
  geom_text(aes(label=toyear,x=fromlibelle, y=0), data=hmy,vjust=0, size=2.5)+
  
  #scale_fill_viridis_c(end=0.9, na.value = "white")+
  #scale_fill_gradientn(colors = cls, na.value = "white", trans="log10", name="log\nstrength")+
  # scale_fill_viridis_c(direction=-1,na.value = "white", option="magma", trans="log10", name="log\nstrength")+
  scale_fill_gradientn(colors = matcols, na.value = "transparent",  name="Overlap %")+
  annotate("text", -Inf, Inf, hjust=-2, vjust=1, label="C", fontface='bold')+
  theme_bw()+
    theme(legend.position = c(0.94,0.22), 
      panel.border = element_blank(),
      panel.grid = element_blank(),
      plot.background = element_rect(color="white", fill="white"),
      axis.title = element_blank(),
      axis.text = element_blank(), # element_text(size=3),
      axis.ticks = element_blank()
    )



# big force directed, use that.
gr = as_tbl_graph(graph_from_data_frame(e2, directed = F, vertices = nodelist %>% filter(EventID_VZ %in% c(e2$from,e2$to)) %>% mutate(nsize=case_when(ab=="A"~lndegree*1.3, T~lndegree)) )) # adjust for glyph difference
fig_network = ggraph(gr  ) +
  geom_node_point(aes(color=YearEvent, size=nsize, shape=ab)) +
  #geom_node_text(aes(label=name)) +
  geom_edge_arc(aes(color=coloryear, alpha=dist),  width=0.1, strength=0.04) +
  #scale_color_viridis(end=0.9)+
  #scale_edge_color_viridis(end=0.9)+
  scale_color_gradientn(colors=netcols, name="Year", 
                        breaks=seq(2009,2021,4), 
                        labels=seq(2009,2021,4) %>% substr(3,4) %>% paste0("'",.)
                          )+
  scale_edge_color_gradientn(colors=netcols, guide="none")+
  scale_edge_alpha(range=c(0.15, 0.5), guide="none")+
  scale_shape_manual(values=abshapes, guide="none")+
  scale_size(range=c(0.2,1.2),  guide="none")+
  scale_x_continuous(expand=expansion(0.02,0))+
  scale_y_continuous(expand=expansion(0.01,0))+
  #coord_flip()+
  #annotate("text", -Inf, Inf, hjust=0, vjust=1, label="A", fontface='bold')+
  theme_void()+
  labs(tag="A")+
  theme(plot.tag=element_text(face = "bold",hjust=0,vjust=1, margin=margin(0,-9,-10,0)))+
  theme(legend.position = c(0.94,0.22), 
        plot.margin = margin(0,0,0,0),
        plot.background = element_rect(color="white", fill="white")
  )

#ggsave("fig_heatmap.pdf", fig_network+fig_heatmap,width=10,height=5, scale=1)




fig_netbee = ggplot(nodelist %>% filter(YearEvent%in%(2015:2019)), 
                    aes(x=as.factor(ab) %>% as.numeric , group=as.factor(ab) %>% as.numeric, color=ab,shape=ab,size=ab, y=lndegree))+
  #geom_boxplot(fill=NA, color="gray30", width=0.2)+
  geom_violin(fill=NA, color="gray50", size=0.1,scale="count", width=1.7, bw=0.9)+
  geom_beeswarm(cex = 3,priority = "random", color="gray50")+
  stat_summary(na.rm=T, shape="-", color="black", fun = median, size=2)+
  scale_shape_manual(values=abshapes)+
  scale_color_manual(values=abcols)+
  scale_size_manual(values=c(0.6,0.3))+
  coord_cartesian(xlim=c(0.6,2.4), expand=T)+
  scale_x_continuous(breaks=1:2,, labels=c("A", "B"))+
  labs(title = expression(paste(bold("B"), " Norm. degree")))+
  scale_y_continuous(expand=expansion(0.01,0))+
  theme_bw()+
  theme(panel.grid.major.x = element_blank(),
        panel.grid.minor.x = element_blank(),
        axis.title = element_blank(),
        plot.margin = margin(1,0,1,1),
        plot.title = element_text(size=8, margin=margin(0,0,0,0)),
        legend.position = "none",
        axis.text.x = element_text(size=6, margin=margin(-1,0,0,0), vjust=1),
        axis.text.y = element_text(size=6, margin=margin(0,-1,0,0), hjust=1),
        axis.ticks = element_blank()
        )

ggsave("fig_heatmap.pdf",
       (fig_network+inset_element(fig_netbee, 0.79,0.69,1,1))+(pspacer)+fig_heatmap+plot_layout(nrow=1, widths=c(1,0.015,1))+plot_annotation( theme = theme(plot.margin = margin(0,1,0,0))),
       width=10,height=4.2, scale=1)


# ggsave("yearnetwork2.png", g, width=5000, height=5000, scale=0.6, units="px")
# write_csv(e2, "edgelist_nov22.csv")

```

## Latent spaces

```{r paper2, eval=F}
# Big UMAP for thematic space + change plots, and the second, language & geo plot
#
pies2 = dopies(festgenrevecs) %>% left_join(ugenre %>% filter(type=="festival") %>% select(V1,V2,event,ab), by="event")

exchange =  c("Berlinale - Berlin IFF", "Sundance", "Venice - Biennale", "Busan IFF", "Toronto - TIFF", "Tallinn Black Nights IFF")

plot.new()# just makes the spline work
fig_thematic = ggplot(pies2, aes(V1, V2))+
  geom_pie_glyph(radius=0.16, slices=attr(pies2, "mains"))+
  geom_point(aes(text=tool), data=ugenre %>% filter(type=="festival", ab=="A"), 
             size=0.5, fill=NA, alpha=0.9, color="black", shape=16)+
   geom_path(data=pies2 %>% ungroup %>%  filter(libelleFestival_NEW_VZ==exchange[1]) %>% select(V1, V2) %>% xspline(shape=-0.2, lwd=2, draw=F) %>% data.frame() %>% rename(V1=x,V2=y) , linewidth=0.5, arrow=arrow(angle=25, length=unit(0.06, "inch"), type="closed"), color="gray10", alpha=0.5)+
  #geom_point(aes(color=colorgenre), data=ugenre %>% filter(type=="film"), size=0.2, fill=NA,show.legend = FALSE)+
  geom_text_repel(aes(label=event,color=colorgenre, size=sizegen %>% log),
                  data=ugenre %>%
                    filter(type %in% c("genre", "film")) %>%
                    group_by(type) %>%
                    filter(type=="genre" | (type=="film" & ( (1:n()) %in% c(15,7, 8, 10, 23, 5)) ) )
                    #mutate(event=case_when(type=="film"~as.character(1:n()), T~type))
                    ,
            lineheight=0.55,
            alpha=0.9, hjust=1,
            bg.color=alpha("white", 0.7),
            show.legend = FALSE, max.overlaps=1000,
            box.padding = 0.2, point.padding = 10, min.segment.length = 999,
            force_pull=0.1,force=2,  max.time = 2)+
  scale_size(range=c(2.8,3.6), guide="none")+
  #scale_radius_manual(values=c(0.2, 0.14), guide="none")+
  #scale_shape_manual(values=abshapes, name="Festival\ntype")+
 
  #annotate("text", -Inf, Inf, hjust=0, vjust=1, label="A", fontface='bold')+
  
  scale_fill_manual(values=sixgcols, name="", breaks=attr(pies2, "mains") )+
  scale_color_manual(values=sixgcols, guide="none", breaks=attr(pies2, "mains") )+
  scale_x_continuous(expand=c(0.01,0))+
  scale_y_continuous(expand=c(0.01,0))+
  theme_void()+
  labs(tag="A")+
  theme(plot.tag=element_text(face = "bold",hjust=0,vjust=1, margin=margin(0,-9,-10,0)))+
  theme(legend.position = c(0.75,0.2),
        plot.background = element_rect( fill="white")
  )


fig_change = divyearplot(genrechangevals %>% 
              mutate(target=dif, lower=diflower, upper=difupper), 
            ex=exchange, 
            yl="Yearly change", ylims = c(-0.005,0.09),
            convert=convertplots, splitab=F, networkstats = F, 
            genrecols = sixgcols, 
            pies=attr(festgenrevecs, "tops"),
            nrowmod=1, contrdiv = F
            )+
  scale_y_continuous(breaks=c(0,0.04,0.08))+
  geom_path(aes(YearEvent, target), data=genrechangevals %>%
              filter(libelleFestival_NEW_VZ==exchange[1]) %>%  
              mutate(target=dif), inherit.aes=F)+
  labs(tag="B")+
  theme(plot.tag=element_text(face = "bold",hjust=1,vjust=1, margin=margin(-5,-9,-11,0)), 
        plot.margin = margin(1,1,0,0))+theme(axis.title.y=element_blank())


## save

ggsave("fig_thematic_map.pdf", fig_thematic+pspacer+fig_change+plot_layout(widths  = c(0.8,0.01,0.2)), width=10,height=5)



# other 2 maps

piesg = dopies(festcountryvecs) %>% left_join(festcountryvecs %>%  select(long,lat,EventID_VZ,ab), by="EventID_VZ")

fig_world = ggplot()+
  #geom_text(aes(V1, V2, color=colorgenre,label=libelleFestival_NEW_VZ), data=ulang %>% sample_n(30), size=3, show.legend = F, inherit.aes = F, alpha=0.9)+
  geom_polygon(mapping= aes(long, lat, group = group), data=mp, inherit.aes = F, color="gray80", fill=NA, size=0.1)+
  geom_pie_glyph(aes(long, lat), radius=0.13, data=piesg, slices=attr(piesg, "mains"))+
  geom_point(aes(long, lat), data=festcountryvecs %>% filter(ab=="A")
             , size=0.4, color="black")+
  #scale_size(range=c(0.3,0.1), guide="none")+
  #scale_radius_manual(values=c(0.16, 0.12), guide="none")+
  #scale_shape_manual(values=c(16,3), name="Festival\ntype")+
  scale_fill_manual(values=sixcols, 
    name="", breaks=levels(festcountryvecs$colorgenre)
                     )+ # add breaks if multiple geoms
  coord_cartesian(xlim=range(festcountryvecs$long)*1.01, ylim=range(festcountryvecs$lat)*1.03,expand=F)+
  theme_void()+
  labs(tag="A")+
  theme(plot.tag=element_text(face = "bold",hjust=0,vjust=1, margin=margin(0,-9,-10,0)))+
  theme(legend.position = c(0.08,0.27),
        legend.background = element_rect(color="transparent", fill="transparent"),
    plot.background = element_rect( fill="white"),
    axis.text = element_text(size=3.8)
  )+
  NULL
fig_eu = fig_world+coord_cartesian(xlim=c(-15, 25), ylim=c(30,51.5))+
  theme(#axis.text = element_blank(), 
        legend.position = "none")+labs(tag=NULL)

fig_eventmap = ggplot(festcountryvecs %>%  # small event location inset
                        group_by(paste(eventlong, eventlat)) %>% 
                        mutate(eventlong=eventlong+runif(n(), -log(n()), log(n()) )) %>% 
                        mutate(eventlat=eventlat+runif(n(), -log(n()), log(n()) ))
                        )+
   coord_cartesian(xlim=range(festcountryvecs$eventlong)*1.05, ylim=range(festcountryvecs$eventlat)*1.07,expand=F)+
  geom_polygon(mapping= aes(long, lat, group = group), data=mp, inherit.aes = F, color="gray80", fill=NA, size=0.2)+
  geom_point(aes(eventlong, eventlat), festcountryvecs,alpha=0.2, position=position_jitter(3,3), color="black", size=1)+
  theme_void()+
  labs(tag="B")+
  theme(plot.tag=element_text(face = "bold",hjust=0,vjust=1, margin=margin(0,-9,-10,0)))+
  theme(legend.position = 'none',
        plot.background = element_rect(fill="white")
        )
        

fig_geomap = fig_world+inset_element(fig_eu, 0.55,0,1,0.5, align_to = "full")+
  inset_element(fig_eventmap, 0.8,0.8,1,1, align_to = "full")




piesl = dopies(festlangvecs) %>% left_join(ulang %>%  select(V1,V2,EventID_VZ,ab), by="EventID_VZ")

fig_langmap = ggplot(piesl, mapping=aes(V1, V2))+
  #geom_text(aes(V1, V2, color=colorgenre,label=libelleFestival_NEW_VZ), data=ulang %>% sample_n(30), size=3, show.legend = F, inherit.aes = F, alpha=0.9)+
  geom_pie_glyph(radius=0.16,data=piesl, slices=attr(piesl, "mains"))+
  
  geom_point(aes( text=tool), data=ulang %>% filter(ab=="A") , size=0.6, color="black")+
  #scale_size(range=c(0.3,0.1), guide="none")+
  #scale_radius_manual(values=c(0.16, 0.12), guide="none")+
  #scale_shape_manual(values=c(16,3), name="Festival\ntype")+
  scale_fill_manual(values=langcols, 
    name="", breaks=levels(ulang$colorgenre)
                     )+ # add breaks if multiple geoms
  theme_void()+
  labs(tag="C")+
  theme(plot.tag=element_text(face = "bold",hjust=0,vjust=1, margin=margin(0,-9,-10,0)))+
  scale_x_continuous(expand=c(0.005,0))+
  theme(legend.position = c(0.07,0.28),
        legend.background = element_rect(color="transparent", fill="transparent"),
    plot.background = element_rect( fill="white")
  )+
  NULL

ggsave("fig_geolang_map.pdf", 
       fig_geomap+
      (pspacer)+
         fig_langmap+plot_layout(heights = c(0.55,0.005, 0.45)), width=10,height=7)



```








## Regressions

```{r, eval=F}
# diversity plot now: all fests as a/b only as a small facet left of the 4 examples


# intercept only prod-dir

# prod vs dir gender
ggplot(festrolevecs)+
  geom_boxplot(aes(ratiopf,1))+
  geom_boxplot(aes(ratiodf,2))

festrolevecs %>% mutate(dif=ratiopf-ratiodf) %>% lm(dif~1, data=., weights=nf) %>% summary

attr(festrolevecs, "sysdivs") %>% filter(YearEvent %in% c(2012,2021))

lm(ratiof~ab, festrolevecs, weights=nf) %>% summary() # gender

festrolevecs %>% filter(grepl("Sundance", libelleFestival_NEW_VZ) ) %>% as.data.frame() %>% arrange(YearEvent) %>% select(rfminboot, rfmaxboot)
festrolevecs %>% filter(grepl("SXSW", libelleFestival_NEW_VZ) ) %>% as.data.frame() %>% arrange(YearEvent) %>% select(rfminboot, rfmaxboot)

# language, AB
lm(indiv~ab, festlangvecs, weights=nf) %>% summary()


# series
nodelist %>% group_by(libelleFestival_NEW_VZ) %>% filter(n_distinct(EventID_VZ)>=2) %>% pull(libelleFestival_NEW_VZ) %>% unique %>% length
nodelist %>% group_by(libelleFestival_NEW_VZ) %>% filter(n_distinct(EventID_VZ)<2) %>% pull(libelleFestival_NEW_VZ) %>% unique %>% length


# gender, AB
lm(ratiofmin~ab, festrolevecs) %>% summary()
lm(ratiofmax~ab, festrolevecs) %>% summary()
lm(ratiof~ab, festrolevecs, weights=nf) %>% summary() # gender


 






library(lme4)

dat = fesfilm2 %>% 
    rename(nsort=nroles) %>%  
    mutate(tmp=paste0(TitleVA, "_", YearOfProduction )) %>% 
    group_by(EventID_VZ) %>%   # for duplicate film removal
    arrange(desc(nsort), is.na(YearOfProduction), .by_group = T) %>%  # prefer more complete entries
    filter(!duplicated(tmp)) %>%  # remove duplicate films within event (works, w ungroup fewer rows)
    group_by(EventID_VZ) %>% filter(n()>=15) %>% 
    ungroup() %>% 
    left_join(filmrole, by = "refFilm", multiple = "all") %>% 
  filter(txtKind!="other") %>% 
    group_by(EventID_VZ) %>% 
      mutate(nf=n_distinct(refFilm)) %>% 
       filter(nf>=15) %>% 
  mutate(txtKind=as.factor(txtKind), txtType=as.factor(txtType))

m = glmer(txtType ~ txtKind + (1+txtType|EventID_VZ), dat, family = "binomial")


```





## Diversity



```{r, eval=F}
tags=function(g, x="", m=margin(0,-9,-10,0)){
  g+labs(tag=x)+
  theme(plot.tag=element_text(face = "bold",hjust=0,vjust=1, margin=m))
}


plotbees = function(vecs, tag, tlab="", col=NULL, cex=3, vw=1.7, comp=F, colvals=abcols){
  g=ggplot(vecs %>% 
             mutate(comp=case_when(
               `PFIAF category`=="Competitive Feature Film Festivals"~"comp", T~"no"
               )), 
           aes(x=as.factor(ab) %>% as.numeric , group=as.factor(ab) %>% as.numeric, color=ab,y=target))+
  #geom_boxplot(fill=NA, color="gray30", width=0.2)+
  geom_violin(fill=NA, color="gray50", size=0.1,scale="count", width=vw)
  
  if(is.null(col)){
    if(!comp) {g=g+geom_beeswarm(aes(color=ab), cex = cex,priority = "random",size=0.5)}
    if(comp) {g=g+geom_beeswarm(aes(color=comp), cex = cex,priority = "random",size=0.5)}
  } else {
    g=g+geom_beeswarm(color=col, cex = cex,priority = "random",size=0.5)
  }
  
  g=g+stat_summary(na.rm=T, shape="-", color="black", fun = median, size=2)+
  #scale_shape_manual(values=abshapes)+
  scale_color_manual(values=colvals)+
  scale_size_manual(values=c(0.6,0.3))+
  coord_cartesian(xlim=c(0.6,2.6), expand=T)+
  labs(title = expr(paste(bold(!!tag), !!tlab)))+
  scale_x_continuous(breaks=1:2, labels=c("A", "B"))+
  scale_y_continuous(expand=expansion(0.01,0))+
  theme_bw()+
  theme(panel.grid.major.x = element_blank(),
        panel.grid.minor.x = element_blank(),
        axis.title = element_blank(),
        plot.margin = margin(1,1,1,1),
        plot.title = element_text(size=8, margin=margin(0,0,0,0)),
        legend.position = "none",
        axis.text.x = element_text(size=6, margin=margin(-1,0,0,0), vjust=1),
        axis.text.y = element_text(size=6, margin=margin(0,-1,0,0), hjust=1),
        axis.ticks = element_blank()
        )
}


  


fig_g1=ggplot(festrolevecs, mapping=aes(ratiopf, ratiodf, color=ratiof, shape=ab, size=ab, text=tool))+
  geom_vline(xintercept = 0.5)+
  geom_hline(yintercept = 0.5)+
  geom_point()+
  scale_size_manual(values =c(1.4,0.8)*1.2, guide="none")+
  scale_shape_manual(values=abshapes, name="Festival\ntype")+
  scale_color_gradientn(colours =rolecols, name="Fraction\nwomen", limits=c(0,1))+
  theme_bw()+
  theme(#legend.position = 'none',
        plot.background = element_rect( fill="white"),
        plot.margin = margin(1,2,-5,0)
  )+
  labs(x="Producers", y="Directors")

fig_gendersys = sysplots(attr(festrolevecs,"sysdivs"), yl="Circuit-wide weighted fraction of women")+lims(y=c(0.2,0.45))+ theme(legend.position = c(0.75,0.1),legend.direction = "horizontal", legend.title = element_blank())

fig_gex = divyearplot(festrolevecs  %>% mutate(target=ratiof, lower=rfminboot, upper=rfmaxboot),
            ex=exrolefests, yl="% of women", convert=convertplots, splitab=F, networkstats = F, ylims=c(0,0.59), nrowmod = 2,  contrdiv = F)+theme(axis.title = element_blank())

fig_gender = tags(fig_g1, "A", margin(0,-11,-10,0)) + 
  (tags(fig_gendersys,"B")+inset_element(
           plotbees(festrolevecs %>% mutate(target=ratiof), "C", "") , 
           0.02,0.6,0.4,0.98 ))+
  tags(fig_gex, "D")+plot_annotation(theme=theme(plot.margin = margin(0,0,-5,0)))+
  plot_layout(widths = c(0.8,1.1, 0.9))

ggsave("fig_gender.pdf", fig_gender, width=10,height=4)


```




```{r, eval=F}
# thematic

tbees = 
  plotbees(festgenrevecs %>% mutate(target=indiv), "C", tlab=" Internal", col="gray50", cex=2.8, vw=1.5) +
  plotbees(festgenrevecs %>% mutate(target=exdiv), "D", tlab=" Contributing", col="gray50", cex=2)+plot_layout(nrow=2)

tdiv2 = (div2plot(festgenrevecs, ex=NULL, convert=F, genrecols = sixgcols %>% darken(0.1))+
           theme(legend.position = "right")+
           guides(color = guide_legend(keyheight = unit(0.6, "lines"), override.aes = list(size = 4)),
                  shape = guide_legend(keyheight = unit(0.6, "lines"))
                  )
           ) %>% tags("E")

fig_thematic_div = 
  (tags(sysplots(attr(festgenrevecs,"sysdivs"), yl="Circuit thematic diversity")+
          theme(legend.position = c(0.85,0.22), legend.title = element_blank()),"A") +
  tags(divyearplot(festgenrevecs  %>% mutate(target=indiv, lower=ilower, upper=iupper), 
            ex=exgenfests, yl="Internal thematic diversity", convert=F, splitab=F, networkstats = F, nrowmod = 2, pies = pies2, genrecols = sixgcols), "B") + plot_layout(widths = c(0.4,0.65))
) /
((tbees | tdiv2 | pspacer)+plot_layout(widths = c(0.3,0.7,0), guides = "keep"))
  

ggsave("fig_thematic_div.pdf", fig_thematic_div, width=10,height=6)

```


```{r, eval=F}
# geo

tbees = 
  plotbees(festcountryvecs %>% mutate(target=indiv), "C", tlab=" Internal", col="gray50", cex=3, vw = 1.4) +
  plotbees(festcountryvecs %>% mutate(target=exdiv), "D", tlab=" Contributing", col="gray50", cex=2.9, vw=1.35)+plot_layout(nrow=2)

tdiv2 = (div2plot(festcountryvecs, ex=NULL, convert=F, genrecols = sixcols %>% darken(0.05))+
           theme(legend.position = "right")+
           guides(color = guide_legend(keyheight = unit(0.6, "lines"), override.aes = list(size = 4)),
                  shape = guide_legend(keyheight = unit(0.6, "lines"))
                  )
           ) %>% tags("E")

fig_geo_div = 
  (tags(sysplots(attr(festcountryvecs,"sysdivs"), yl="Circuit geographic diversity")+
          theme(legend.position = c(0.6,0.22), legend.title = element_blank()),"A") +
  tags(divyearplot(festcountryvecs  %>% mutate(target=indiv, lower=ilower, upper=iupper), 
            ex=exgeofests, yl="Internal geographic diversity", convert=F, splitab=F, networkstats = F, nrowmod = 2, pies=piesg, genrecols = sixcols), "B") + plot_layout(widths = c(0.35,0.65))
) /
((tbees | tdiv2 | pspacer)+plot_layout(widths = c(0.3,0.7,0), guides = "keep"))+
  plot_annotation(theme=theme(plot.margin=margin(0,0,0,0)))
  

ggsave("fig_geo_div.pdf", fig_geo_div, width=10,height=6)

```


```{r, eval=F}
# language

tbees = 
  plotbees(festlangvecs %>% mutate(target=indiv), "C", tlab=" Internal", col="gray50", cex=3, vw = 1.7) +
  plotbees(festlangvecs %>% mutate(target=exdiv), "D", tlab=" Contributing", col="gray50", cex=2.3, vw=1.5)+plot_layout(nrow=2)

tdiv2 = (div2plot(festlangvecs, ex=NULL, convert=F, genrecols = langcols)+
           theme(legend.position = "right")+
           guides(color = guide_legend(keyheight = unit(0.6, "lines"), override.aes = list(size = 4)),
                  shape = guide_legend(keyheight = unit(0.6, "lines"))
                  )
           ) %>% tags("E")

fig_lang_div = 
  (tags(sysplots(attr(festlangvecs,"sysdivs"), yl="Circuit language diversity")+
          theme(legend.position = c(0.6,0.1),legend.direction = "horizontal", legend.title = element_blank()),"A") +
  tags(divyearplot(festlangvecs  %>% mutate(target=indiv, lower=ilower, upper=iupper), 
            ex=exlangfests, yl="Internal language diversity", convert=F, splitab=F, networkstats = F, nrowmod = 2, pies=piesl, genrecols = langcols), "B")+ plot_layout(widths = c(0.4,0.65))
) /
((tbees | tdiv2 | pspacer)+plot_layout(widths = c(0.3,0.7,0), guides = "keep"))
  

ggsave("fig_lang_div.pdf", fig_lang_div, width=10,height=6)




## lang centre

x= dist2(langlat, attr(festlangvecs, "latentcentre"), method="euclidean", norm="none")[,1]
names(x)=rownames(langlat)
sort(x) %>% head

# lang vs geo div?

x = festlangvecs %>% select(EventID_VZ,LibelleEvent_NEW_VZ, ab, indiv, `PFIAF category`, YearEvent) %>% left_join(festcountryvecs %>% select(EventID_VZ, indiv) %>% rename(gindiv=indiv), by="EventID_VZ")

ggplot(x, aes(indiv, gindiv, color=ab))+
  geom_point()

cor.test(x$indiv, x$gindiv)


festlangvecs %>% group_by(`PFIAF category`, ab) %>% count
xx = x %>% mutate(competitive = case_when(`PFIAF category` %in% c("Competitive Feature Film Festivals", "Competitive Specialised Feature Film Festivals") ~ "competitive", T~"noncomp"))

ggplot(xx, aes(indiv, gindiv, shape=ab, color=competitive))+
  geom_point()+
  scale_shape_manual(values=abshapes)+
  labs(x="Language internal div", y="Geo internal div")+
  geom_text(aes(label=LibelleEvent_NEW_VZ), data=xx %>%  filter(YearEvent==2019, `PFIAF category` %in% c("Competitive Feature Film Festivals")), hjust=0, size=3)

```



## Appendix

```{r}

mains=levels(festgenrevecs$colorgenre) %>% head(-1)
others = setdiff(
  table( attr(festgenrevecs, "filmfestvecs")$firstfilmkind) %>% sort(decreasing = T) %>% names(),
  mains)
  
u = umap( attr(festgenrevecs, "filmfestvecs") %>% filter(!duplicated(tmp)) %>% 
           select(starts_with("V")) # %>% ungroup() %>% mutate(V1=V1*runif(n(), 0.99,1.01 ))
           ,
           method = "umap-learn")$layout %>% 
  as.data.frame() %>% 
  cbind(attr(festgenrevecs, "filmfestvecs") %>% filter(!duplicated(tmp))  %>% select(-starts_with("V"))) 

u2 = u %>% mutate(colorgenre=case_when(firstfilmkind %in% mains ~ firstfilmkind, T~"others")) %>% mutate(colorgenre=fct_relevel(colorgenre, c(mains, "others")))

xcols = c(sixgcols %>% head(-1), "gray50")

g = ggplot(u2, aes(V1, V2, color=colorgenre))+
  geom_point(size=0.3)+
  scale_color_manual(values=xcols, name="")+
  theme_void()+
  theme(axis.title = element_blank(),
        legend.position = "right", legend.text = element_text(size=12),
        plot.background = element_rect(fill="white", color="gray10")
      #  panel.border  = element_rect(linewidth=0.5, color="gray10", fill=NA)
        )+
   guides(color = guide_legend(keyheight = unit(1, "lines"), override.aes = list(size = 4)))
ggsave("fig_sup_latentmap.png",g, width=10, height=7)

```

## Language latent space, UMAP

(this map is hard to project in 2D well, because many languages are very far from other languages due to no relation, having only incidental similarities or geographic proximity)

```{r}


attr(festlangvecs, "filmfestvecs") %>% 
  group_by(txtKind2) %>% 
  mutate(n=n()) %>% summarise(across(everything(), first)) %>%  select(n, txtKind2, txtKind3) %>% rename(txtKind=txtKind3) %>%
  left_join(attr(langlat, "latmap")) %>% 

ggplot( aes(V1,V2,label=txtKind2, size=log(n)))+
  geom_text_repel( box.padding = 0, min.segment.length = 9999, max.time = 5, max.overlaps = 1000000)+
  scale_size(range=c(1.6,3))+
  theme_void()+
  theme(legend.position = "none",
        panel.border = element_rect(fill=NA),
        plot.background = element_rect(fill="white")
        )

ggsave("fig_sup_langmap.png", width=10, height=8, scale=0.6)
```

